[
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "f783adc1-13cf-46f7-ad1f-733646933dba",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC001-Multi-role Authentication Success",
    "description": "Verify that users across all roles (Faculty, Exam Cell, TC Admin, TC Head, Assessment Agency) can login successfully with correct credentials including OTP verification.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to start login for admin-related roles.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Enter email and password for Faculty role and click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input OTP code for Faculty role and click Verify & Login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Resend Code' to attempt getting a new OTP and retry verification for Faculty role.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical OTP verification flow issue and network error preventing successful login for Faculty role. Resend OTP functionality is missing or misconfigured. Further login tests for other roles cannot proceed until this is fixed.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207406796943//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.172Z",
    "modified": "2025-08-03T07:50:06.954Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "d26bd332-4115-47f4-bf60-7358d782ada6",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC002-Authentication Failure with Incorrect Credentials",
    "description": "Verify that login fails when an incorrect username, password, or OTP is provided.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to test login with invalid credentials.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Enter invalid email and password, then click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invaliduser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Retry login with invalid credentials or check network connection.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Back to Login' link to return to Admin Login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Enter invalid email and password, then click Sign In to verify login failure and error message.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invaliduser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Test login with valid username and password, then enter incorrect OTP if prompted to verify login failure.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Enter incorrect OTP '000000' and click 'Verify & Login' to verify login failure and error message.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test failed: Login did not behave as expected with invalid credentials or OTP.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login failure tests with invalid username/password and incorrect OTP were performed. However, network errors prevented clear validation of error messages for login failure. Please investigate and resolve network issues to enable proper testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 (Unprocessable Content) (at http://localhost:8000/admin/login:0:0)\n[ERROR] Error: Error: HTTP error! status: 422\n    at http://localhost:8000/admin/login:127:27 (at http://localhost:8000/admin/login:158:24)\n[ERROR] Failed to load resource: the server responded with a status of 422 (Unprocessable Content) (at http://localhost:8000/admin/login:0:0)\n[ERROR] Error: Error: HTTP error! status: 422\n    at http://localhost:8000/admin/login:127:27 (at http://localhost:8000/admin/login:158:24)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/17542074966914//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.178Z",
    "modified": "2025-08-03T07:51:36.834Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "01327e53-2e11-4328-a113-c83324efb32d",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC003-Role-based Access Control for Exam Schedule Visibility",
    "description": "Verify exam schedules are visible only according to user roles and schedule statuses, adhering to access filter rules.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to proceed to login page for Faculty role.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input Faculty credentials and sign in.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input OTP code and verify to complete Faculty login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Resend Code' to get a new OTP and then enter the new OTP to complete login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input the new OTP code (assuming '000000' is placeholder) and click 'Verify & Login' to complete Faculty login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to OTP verification failure blocking Faculty login. Unable to proceed with exam schedule visibility verification for any user roles. Issue reported for resolution.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207426207185//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.184Z",
    "modified": "2025-08-03T07:50:26.362Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "3efa017a-d387-4a29-a023-51899d0a15ab",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC004-Exam Schedule Approval Workflow Transitions",
    "description": "Verify that the exam schedule status changes follow the defined workflow and only authorized roles can perform actions based on status.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to proceed with Faculty login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input Faculty email and password, then click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input OTP code and click Verify & Login to complete Faculty login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to OTP verification failure. Unable to login as Faculty to proceed with exam schedule status workflow testing. Issue reported for resolution.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207376045998//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.190Z",
    "modified": "2025-08-03T07:49:36.239Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "22fb67fa-2446-4365-8ec8-d4cdbc7f3db8",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC005-File Number Generation on Final Approval",
    "description": "Verify unique, formatted 18-character file numbers are generated correctly on final approval by Assessment Agency including correct financial year and incrementing serial number.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to proceed with admin portal access.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password for TC Admin/Head and click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input the 6-digit OTP code and click Verify & Login to complete login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Resend Code' to get a new OTP code and then input the new code to verify and login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input the new OTP code received via email and click 'Verify & Login' to complete login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to OTP verification failure blocking admin login. Unable to proceed with verifying unique 18-character file numbers on final approval. Please fix OTP verification to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/175420744291995//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.195Z",
    "modified": "2025-08-03T07:50:43.066Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "200bef60-b1cb-484b-9c6c-6ec3f8b4f759",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC006-Email Notification on Schedule Status Changes",
    "description": "Verify that professional templated emails are sent automatically on schedule submission, approval (Exam Cell, TC Admin/Head), rejection, hold, and final approval.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to proceed to login page for Faculty.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input Faculty email and password and click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Enter the OTP code received by email and click Verify & Login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Resend Code' to attempt receiving a new OTP and proceed with login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify professional templated emails on schedule submission, approval, rejection, hold, and final approval could not be fully completed due to a critical blocker at the OTP verification step during Faculty login. The system requires a valid OTP sent to the user's email to proceed, which was not provided. Without successful login, the exam schedule submission and approval workflows could not be tested, and thus the email notifications could not be verified. Please provide the OTP or resolve the OTP verification issue to continue testing. Task incomplete.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207457266196//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.201Z",
    "modified": "2025-08-03T07:50:57.420Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "a0651711-bd12-4547-bb58-83c9490d4b31",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC007-Protected Content Viewing â€“ Image and Signature URL Protection",
    "description": "Verify sensitive images like signatures are served via protected URLs with session token validation, no caching, and anti-copy mechanisms applied including canvas conversions.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to proceed to login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password for faculty user and click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input the OTP code and click Verify & Login to complete login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify sensitive images served via protected URLs with session token validation, no caching, and anti-copy mechanisms could not be completed due to inability to login. The OTP verification step blocks login as no valid OTP was provided or available. This prevents access to the exam schedule view containing sensitive signature images, thus blocking all further verification steps. The OTP issue has been reported as a blocking problem. Task stopped.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207379097923//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.207Z",
    "modified": "2025-08-03T07:49:39.255Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "d1c7feb2-23ef-4440-a065-4db0df449613",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC008-JavaScript Page Protection against Developer Tools and Shortcuts",
    "description": "Verify that right-click context menu, keyboard shortcuts (such as Ctrl+Shift+I, F12), copy, paste, drag actions are blocked consistently across supported browsers and security alerts/logs are generated.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to access the admin portal for further testing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password, then click Sign In to access admin portal.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Enter the OTP code and click Verify & Login to access the admin portal.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        # Click Verify & Login button to complete login and access admin portal.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to OTP verification failure preventing login. Cannot proceed with security feature tests without access to admin portal. Issue reported.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207402395919//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.212Z",
    "modified": "2025-08-03T07:50:02.537Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "12743a77-c1a9-4cea-9b16-f7d309e73b5d",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC009-Bulk Student Data Upload with Date Format and Null Value Fixes",
    "description": "Verify bulk student data upload accepts various date formats (including DD-MM-YYYY), converts them properly to MySQL format, handles empty columns, applies default values, and logs errors or fixes.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to access admin portal for bulk student data upload.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password, then click Sign In to access admin portal.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Enter the OTP code and click Verify & Login to complete login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        # Retry OTP verification with a new code or use the Resend Code option to get a fresh OTP.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input the new OTP code received and click Verify & Login to complete login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('654321')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "OTP verification is failing repeatedly, blocking access to the admin portal. Unable to proceed with bulk student data upload testing. Reporting the issue and stopping further actions.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207442600946//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.219Z",
    "modified": "2025-08-03T07:50:42.713Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "e2ff3aba-ea84-4cdd-8b2b-c5eef22869cc",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC010-Secure PDF and File Serving with Access Control",
    "description": "Verify stored PDF files and images are served through secure custom routes enforcing access control, correct MIME types, and inline display rendering.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to proceed with authorized user login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password for authorized user and click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input the OTP code and click Verify & Login to complete authorized user login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to complete login because OTP verification fails with the provided code. Cannot proceed with secure file serving tests without successful authentication.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207390061778//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.226Z",
    "modified": "2025-08-03T07:49:50.218Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "9ebcab62-1bd3-4bf2-a270-da781aad18d8",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC011-Print Functionality with Temporary Protection Disable and Restoration",
    "description": "Verify that the print function opens native print dialog, disables content protections (such as canvas and shortcut blocks) during printing, and restores all protections after printing without errors.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to proceed to login page for Faculty user.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password for Faculty user and click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input OTP code and click Verify & Login to complete login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to complete login because of OTP verification requirement. Without successful login, the print function test cannot proceed. Please provide valid OTP or alternative access to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207397420552//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.233Z",
    "modified": "2025-08-03T07:49:57.571Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "2c8876d0-947d-4cb7-93e8-ea126fc09766",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC012-Unauthorized Access Redirect and Error Message Display",
    "description": "Verify all unauthorized or invalid accesses to protected routes redirect the user to login page with clear, user-friendly messages, and no sensitive information leaks.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Attempt to access protected URLs without login to verify redirection to login page with appropriate message.\n        await page.goto('http://localhost:8000/admin/exam-schedules', timeout=10000)\n        \n\n        # Attempt to access other protected URLs like images and PDFs without login to verify redirection and messages.\n        await page.goto('http://localhost:8000/admin/protected-image.jpg', timeout=10000)\n        \n\n        # Attempt to access a protected PDF URL without login to verify redirection and message.\n        await page.goto('http://localhost:8000/admin/protected-file.pdf', timeout=10000)\n        \n\n        # Log in as Faculty user to test expired session and role-based unauthorized actions.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input OTP to complete login and access protected features for further testing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion as expected result is unknown.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to OTP verification failure preventing login. Unauthorized access to protected routes without login was verified successfully. Further tests requiring login cannot proceed until OTP issue is resolved.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207413193977//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.240Z",
    "modified": "2025-08-03T07:50:13.433Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "0374e37e-7977-484d-871e-fb3ca300be09",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC013-Security Logging of Access Attempts and Email Sending States",
    "description": "Verify all relevant security events like login attempts, unauthorized access, developer tool usage attempts, and status of email notifications are logged accurately for audit purposes.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to start login attempts for security event testing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Perform a successful login attempt with valid credentials.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate a failed login attempt to verify logging of failed attempts.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Perform a failed login attempt with invalid credentials and verify the event is logged with all required details.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invaliduser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Retry the failed login attempt to bypass the network error and verify logging of failed login attempts.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invaliduser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Back to Login' to return to Admin Login page and continue failed login attempts and brute force testing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Perform multiple failed login attempts rapidly to simulate brute force attack and verify logging and alerting.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invaliduser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Perform multiple rapid failed login attempts to simulate a brute force attack and verify logging and alerting.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invaliduser1@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword1')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Retry the brute force login attempt to bypass the network error and verify logging and alerting.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invaliduser2@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword2')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Back to Login' to return to Admin Login page and continue with developer tool usage attempts and email notification logging verification.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Perform login as TC Admin to access exam schedule management and trigger email notifications for logging verification.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcadmin@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion as expected result is unknown.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing of login attempts (successful, failed, brute force) and developer tool usage attempts was performed. However, login as TC Admin to test email notification logging failed, blocking completion of the final verification step. Please verify TC Admin credentials and system login functionality. Stopping further testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 (Unprocessable Content) (at http://localhost:8000/admin/login:0:0)\n[ERROR] Error: Error: HTTP error! status: 422\n    at http://localhost:8000/admin/login:127:27 (at http://localhost:8000/admin/login:158:24)\n[ERROR] Failed to load resource: the server responded with a status of 422 (Unprocessable Content) (at http://localhost:8000/admin/login:0:0)\n[ERROR] Error: Error: HTTP error! status: 422\n    at http://localhost:8000/admin/login:127:27 (at http://localhost:8000/admin/login:158:24)\n[ERROR] Failed to load resource: the server responded with a status of 422 (Unprocessable Content) (at http://localhost:8000/admin/login:0:0)\n[ERROR] Error: Error: HTTP error! status: 422\n    at http://localhost:8000/admin/login:127:27 (at http://localhost:8000/admin/login:158:24)\n[ERROR] Failed to load resource: the server responded with a status of 422 (Unprocessable Content) (at http://localhost:8000/admin/login:0:0)\n[ERROR] Error: Error: HTTP error! status: 422\n    at http://localhost:8000/admin/login:127:27 (at http://localhost:8000/admin/login:158:24)\n[ERROR] Failed to load resource: the server responded with a status of 422 (Unprocessable Content) (at http://localhost:8000/admin/login:0:0)\n[ERROR] Error: Error: HTTP error! status: 422\n    at http://localhost:8000/admin/login:127:27 (at http://localhost:8000/admin/login:158:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207701871809//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.246Z",
    "modified": "2025-08-03T07:55:02.040Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "ee15e9bd-3d6a-48fa-8ad2-3297d410574c",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC014-Student Data Validation on Profile Creation and Editing",
    "description": "Verify data validations are enforced correctly when creating or editing student profiles, including mandatory fields, formats, and fallback/default values for optional or null fields.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to access admin portal for student profile management.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password and click Sign In to login as faculty.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input a dummy OTP code to attempt login and proceed to admin dashboard.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The OTP verification step is blocking access to the admin dashboard, preventing further testing of student profile data validations. A dummy OTP does not work and no bypass is available. The issue has been reported. Task is now complete and stopped as per instructions.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207406026034//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.252Z",
    "modified": "2025-08-03T07:50:06.196Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "152fb7ff-e10c-423d-94f0-f668bf95f16f",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC015-TC Management Role-based Functionalities",
    "description": "Verify Training Centre management (centres, layouts, shot codes) is accessible only by authorized roles and supports full CRUD operations with validation.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to proceed with TC Admin or TC Head login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input TC Admin email and password, then click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcadmin@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the Sign In button to attempt login as TC Admin.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try login as TC Head or check for alternative authorized role credentials to proceed with Training Centre management testing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tchead@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The testing for Training Centre management access and CRUD operations could not be completed due to a critical issue with login functionality. Attempts to login as TC Admin and TC Head failed repeatedly with no success or error feedback, indicating a backend or authentication problem. This prevents verification of role-based access control and CRUD operations for Training Centre management. The issue has been reported for resolution. Further testing should resume once the login problem is fixed.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 (Unprocessable Content) (at http://localhost:8000/admin/login:0:0)\n[ERROR] Error: Error: HTTP error! status: 422\n    at http://localhost:8000/admin/login:127:27 (at http://localhost:8000/admin/login:158:24)\n[ERROR] Failed to load resource: the server responded with a status of 422 (Unprocessable Content) (at http://localhost:8000/admin/login:0:0)\n[ERROR] Error: Error: HTTP error! status: 422\n    at http://localhost:8000/admin/login:127:27 (at http://localhost:8000/admin/login:158:24)\n[ERROR] Failed to load resource: the server responded with a status of 422 (Unprocessable Content) (at http://localhost:8000/admin/login:0:0)\n[ERROR] Error: Error: HTTP error! status: 422\n    at http://localhost:8000/admin/login:127:27 (at http://localhost:8000/admin/login:158:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207436910596//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.257Z",
    "modified": "2025-08-03T07:50:37.150Z"
  },
  {
    "projectId": "11f2e4ec-92ef-4435-9933-8dbae8c72f2c",
    "testId": "3e45e785-ab00-4753-b850-de17c98df735",
    "userId": "64d8d4b8-c011-7058-52cd-29dac2cfe8ad",
    "title": "TC016-Dashboard Data and Visualization Access per Role",
    "description": "Verify that dashboards display appropriate data and visualizations relevant to the logged-in user's role accurately.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Login to proceed with Faculty login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password for Faculty and click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('tcfaculty@gmail.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input the OTP code and click Verify & Login to complete Faculty login and access the dashboard.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to OTP verification failure. Unable to proceed with dashboard verification for Faculty role or other roles without valid OTP or bypass. Please resolve OTP issue to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:8000/admin/verify-otp:0:0)\n[ERROR] Error: Error: HTTP error! status: 400\n    at http://localhost:8000/admin/verify-otp:161:27 (at http://localhost:8000/admin/verify-otp:192:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64d8d4b8-c011-7058-52cd-29dac2cfe8ad/1754207393253428//tmp/test_task/result.webm",
    "created": "2025-08-03T07:47:00.263Z",
    "modified": "2025-08-03T07:49:53.443Z"
  }
]
